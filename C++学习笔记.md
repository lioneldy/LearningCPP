# C++学习笔记

-----

## 继承构造函数

### 为什么要引入继承构造函数？

如果基类的构造函数很多，那么子类的构造函数想要实现同样多的构造接口，必须一一调用基类的构造函数，有点麻烦，所以C++11引入继承构造函数

```
class _A
    {
public:
    _A( int _InInt ) {;}
    _A( double _InDouble, int _InInt ) {;}
    _A( float _InFloat, int _InInt, const char* _Char ) {;}
    };
 
   
class _B : public _A
    {
public:
   using _A::_A;            // 使用_A中的构造函数
    // Somthing...
    virtual void _ExtraInterface() {;}
    };
```

（1） C++11中的继承构造函数特性最有用的场合就是，派生类只是在基类的基础上添加了几个新的接口, 这个时候继承构造函数最能够展现威力.但是缺陷就是, 继承构造函数只会初始化基类中的成员变量(毕竟只是从基类继承下来的), 对于派生类中的变量无能为力,

（2）不过，可以配合另一个C++11中的新特性: 数据成员就地初始化，来解决这个问题。但是，这种做法导致子类的成员不能在构造函数的参数列表中体现出来。

（3）一旦，子类继承了基类的构造函数，那么子类就不会自动生成默认构造函数。

### 构造函数与析构函数的调用顺序

- 对于构造函数：基类构造函数 > 子类成员变量构造函数 > 子类构造函数
- 对于析构函数：子类析构函数 > 子类成员变量析构函数 > 基类析构函数

可以看出构造函数的调用过程和析构函数的调用过程正好相反。

## 什么是可调用对象？

C++中有几种可调用对象：函数，函数指针，lambda表达式，bind创建的对象，以及重载了函数调用符的类。

## 四叉树算法

#### 如何判断一个点是否落入多个矩形空间内？

若向量a与向量b的向量积为k，如果k>0时，那么a正旋转到b的角度为<180°，如果k<0，那么a正旋转到b的角度为>180°,如果k=0 那么a，b向量平行。

利用这一特性可以判断点p是否在两条线段之间。

## 多线程

### c++线程中的几种锁

- 互斥锁
	- 互斥锁用于控制多个线程对他们之间共享资源互斥访问的一个信号量。也就是说是为了避免多个线程在某一时刻同时操作一个共享资源。例如线程池中的有多个空闲线程和一个任务队列。任何是一个线程都要使用互斥锁互斥访问任务队列，以避免多个线程同时访问任务队列以发生错乱。
	- 在某一时刻，只有一个线程可以获取互斥锁，在释放互斥锁之前其他线程都不能获取该互斥锁。如果其他线程想要获取这个互斥锁，那么这个线程只能以阻塞方式进行等待。
- 条件锁
	- 条件锁就是所谓的条件变量，某一个线程因为某个条件为满足时可以使用条件变量使改程序处于阻塞状态。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。
- 自旋锁
	- 如果一个线程想要获取一个被使用的自旋锁，那么它会一致占用CPU请求这个自旋锁使得CPU不能去做其他的事情，直到获取这个锁为止，这就是“自旋”的含义。
- 读写锁
	- 处于读锁操作时可以允许其他线程和本线程的读锁， 但不允许写锁， 处于写锁时则任何锁操作都会睡眠等待

## I/O模型

- 阻塞（Blocking）
- 非阻塞（Non-blocking）
- 同步（Synchronous）
- 异步（Asynchronous

阻塞非阻塞是等待 I/O 完成的方式，阻塞要求用户程序停止执行，直到 I/O 完成，而非阻塞在 I/O 完成之前还可以继续执行。

同步异步是获知 I/O 完成的方式，同步需要时刻关心 I/O 是否已经完成，异步无需主动关心，在 I/O 完成时它会收到通知。

### select poll epoll

这三个都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。可以说，新出现的实现是为了修复旧实现的不足。

#### 1. select

```c++
int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```

- fd_set 表示描述符集合；
- readset、writeset 和 exceptset 这三个参数指定让操作系统内核测试读、写和异常条件的描述符；
- timeout 参数告知内核等待所指定描述符中的任何一个就绪可花多少时间；
- 成功调用返回结果大于 0；出错返回结果为 -1；超时返回结果为 0。

每次调用`select()`都需要将`fd_set *readfds`, `fd_set *writefds`, `fd_set *exceptfds`链表内容全部从用户进程内存中复制到操作系统内核中，内核需要将所有 `fd_set` 遍历一遍，这个过程非常低效。

返回结果中内核并没有声明哪些`fd_set`已经准备好了，所以如果返回值大于 0 时，程序需要遍历所有的`fd_set`判断哪个 I/O 已经准备好。

在 Linux 中 select 最多支持 1024 个 fd_set 同时轮询，其中 1024 由 Linux 内核的 FD_SETSIZE 决定。如果需要打破该限制可以修改 FD_SETSIZE，然后重新编译内核。

#### 2. poll

```c++
struct pollfd {
    int fd;       //文件描述符
    short events; //监视的请求事件
    short revents; //已发生的事件
};

int poll (struct pollfd *fds, unsigned int nfds, int timeout);
```

它和`select()`功能基本相同。同样需要每次将`struct pollfd *fds`复制到内核，返回后同样需要进行轮询每一个`pollfd`是否已经I/O准备好。`poll()`取消了 1024 个描述符数量上限，但是数量太大以后不能保证执行效率，因为复制大量内存到内核十分低效，所需时间与描述符数量成正比。`poll()`在`pollfd`的重复利用上比`select()`的`fd_set`会更好。

如果在多线程下，如果一个线程对某个描述符调用了`poll()`系统调用，但是另一个线程关闭了该描述符，会导致`poll()`调用结果不确定，该问题同样出现在`select()`中。

#### 3. epoll

```c++
int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
```

epoll 仅仅适用于 Linux OS。

它是 select 和 poll 的增强版，更加灵活而且没有描述符限制。它将用户关心的描述符放到内核的一个事件表中，从而只需要在用户空间和内核空间拷贝一次。

select 和 poll 方式中，进程只有在调用一定的方法后，内核才对所有监视的描述符进行扫描。而 epoll 事先通过 `epoll_ctl()` 来注册描述符，一旦基于某个描述符就绪时，内核会采用类似 callback 的回调机制，迅速激活这个描述符，当进程调用 `epoll_wait()` 时便得到通知。

新版本的 `epoll_create(int size)` 参数 size 不起任何作用，在旧版本的 epoll 中如果描述符的数量大于 size，不保证服务质量。

`epoll_ct()` 执行一次系统调用，用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理。

`epoll_wait()` 取出在内核中通过链表维护的 I/O 准备好的描述符，将他们从内核复制到程序中，不需要像 select/poll 对注册的所有描述符遍历一遍。

epoll 对多线程编程更有友好，同时多个线程对同一个描述符调用了 `epoll_wait` 也不会产生像 `select/poll` 的不确定情况。或者一个线程调用了 `epoll_wait` 另一个线程关闭了同一个描述符也不会产生不确定情况。

## 继承

多态是如何实现的？

通过父类调用接口，如何确定调用的是父类还是子类的接口？

## 智能指针

- auto_ptr \<T\>
	- 普通指针在delete的时候只会释放指针所指向的内存空间，但是指针依旧存在并指向该内存空间，如果不把指针置为null该指针将变为野指针。 智能指针在delete之后会自动删除此指针，避免了野指针的出现。
	- auto_ptr在进行复制动作的时候会使它（被复制物）指向null
- unique_ptr \<T\>
- shared_ptr \<T\>
- weak_ptr \<T\>

## 内联函数与宏定义的区别

1. 内联函数在运行时可调试，而宏定义不可以;
2. 编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），而宏定义则不会； 
3. 内联函数可以访问类的成员变量，宏定义则不能； 
4. 在类中声明同时定义的成员函数，自动转化为内联函数。

在调用一个内联函数时，编译器首先检查调用是否正确（进行类型安全检查，或者进行自动类型转换，当然对所有的函数都一样）。如果正确，内联函数的代码就会直接替换函数调用，于是省去了函数调用的开销。这个过程与预处理有显著的不同，因为预处理器不能进行类型安全检查，或者进行自动类型转换。

## memmove与memcpy的区别及实现

### 1.与字符串函数strcpy区别：

- memcpy与memmove都是对内存进行拷贝可以拷贝任何内容，而strcpy仅是对字符串进行操作。
- memcpy与memmove拷贝多少是通过其第三个参数进行控制而strcpy是当拷贝至'\0'停止。

### 2.函数说明：         

- memcpy函数的功能是从源src所指的内存地址的起始位置开始拷贝N个字节到目标dst所指的内存地址的起始位置中。
- memmove函数的功能同memcpy基本一致，但是当src区域和dst内存区域重叠时，memcpy可能会出现错误，而memmove能正确进行拷贝。

## 覆盖、重载和多态的区别及联系

### 覆盖：

在基类中定义了一个非虚拟函数，然后在派生类中又定义了一个同名同参数同返回类型的函数，这就是覆盖了。在派生类对象上直接调用这个函数名，只会调用派生类中的那个。

### 重载：

在基类中定义了一个非虚拟函数，然后在派生类中定义一个同名，但是具有不同的参数表的函数，这就是重载。在派生类对象上调用这几个函数时，用不同的参数会调用到不同的函数，有可能会直接调用到基类中的那个。

### 多态：

在基类中定义了一个虚拟函数，然后在派生类中又定义一个同名，同参数表的函数，这就是多态。多态是这3种情况中唯一采用动态绑定技术的一种情况。也就是说，通过一个基类指针来操作对象，如果对象是基类对象，就会调用基类中的那个函数，如果对象实际是派生类对象，就会调用派声类中的那个函数，调用哪个函数并不由函数的参数表决定，而是由函数的实际类型决定。

## "."操作与"->"操作的区别

"."操作用于对象访问其成员，而"->"则是指针访问对象成员。

### 迭代器

迭代器是一种将`operator*, operator-->, operator++, operator--`等指针相关操作予以重载的模板类。

## 面向对象的五个基本原则： 

- 单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。 
- 开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。 
- Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。 
- 依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 
- 接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口

## 内存管理

1. 栈区（stack）— 由编译器自动分配释放 ，存放为运行函数而分配的局部变量、函数参数、返回数据、返回地址等。
2. 堆区（heap） — 一般由程序员分配释放， new, malloc之类的，若程序员不释放，程序结束时可能由OS回收 。
3. 全局区（静态区）（static）— 存放全局变量、静态数据、常量。程序结束后由系统释放。
4. 文字常量区 — 常量字符串就是放在这里的。程序结束后由系统释放。
5. 程序代码区 — 存放函数体（类成员函数和全局函数）的二进制代码。

### 堆和栈的区别

1. **管理方式不同：**对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。
2. **空间大小不同：**一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的。
3. **碎片问题：**对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。
4. **生长方向不同：**对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。
5. **分配方式不同：**堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。
6. **分配效率不同：**栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。

### calloc和malloc和alloca的区别

calloc跟malloc的区别：calloc在动态分配完内存后，自动初始化该内存空间为零，而malloc不初始化，里边数据是随机的垃圾数据。_alloca是在栈(stack)上申请空间，用完马上就释放。


## unordered_map的key值限定

只能使用基本类型以及string和智能指针作为unordered_map的key值，如果需要使用别的自定义类型作为key值需要实现对应的hash函数。

## 静态数组与动态数组的区别

静态数组[]分配在栈上，由系统自动管理；动态数组通过new申请分配在堆上，需要用完后自己用delete释放空间。

## new/delete malloc/free区别和联系

- 一个new对应一个delete，一个new[]对应一个delete[]，一个malloc对应一个free
- malloc开辟空间类型大小需手动计算，new是由编译器自己计算
- malloc返回类型为void*,必须强制类型转换对应类型指针，new则直接返回对应类型指针
- malloc开辟内存时返回内存地址要检查判空，因为若它可能开辟失败会返回NULL；new则不用判断，因为内存分配失败时，它会抛出异常bac_alloc,可以使用异常机制
- 无论释放几个空间大小，free只传递指针，多个对象时delete需加[]（原因在第3）
- malloc/free为函数只是开辟空间并释放，new/delete则不仅会开辟空间，并调用构造函数和析构函数进行初始化和清理
- new/delete底层是基于malloc/free来实现的，而malloc/free不能基于new/delete实现
- 因为new/delete是操作符，它调用operator new / operator delete,它们可以被重载，在标准库里它有8个重载版本；而malloc/free不可以重载

## 大小端模式

- 大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。
- 小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。

## 指针常量与常量指针

1. const int p; 
- const int* p; 
- int const* p; 
- int * const p;
- const int * const p;
- int const * const p;

从右往左读，遇到p就换成p is a，遇到*就换成point to.

const在\*左边说明指向的内容是常量，const在\*右边说明指针是常量

1. p is a int const
2. p is a point to int const
3. p is a point to const int
4. p is a const point to int
5. p is a const point to int const
6. p is a const point to const int

## struct与union

struct的长度一定是最长的数据元素的整数倍，union的大小就是最长的数据元素的大小，union内部各数据元素共享这一内存。

## static

### 静态成员

在C++中，静态成员是属于整个类的而不是某个对象，静态成员变量只存储一份供所有对象共用。所以在所有对象中都可以共享它。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存。

### 静态成员函数

静态成员函数不能访问一般的数据成员，只能访问静态数据成员，也只能调用其他的静态成员函数。

通常，当前对象的地址(this)是被隐式地传递到被调用的函数的，但一个静态成员函数没有this，所以它无法访问一般的成员。

一个静态成员是与一个类相连，而不是与一个特定的对象相连。

### 全局变量和全局静态变量的区别

- 全局变量是不显式用static修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过extern 全局变量名的声明，就可以使用全局变量。
- 全局静态变量是显式用static修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用extern声明也不能使用。

## const

### const修饰成员变量

- 只有一个const，如果const位于\*左侧，表示指针所指数据是常量，不能通过解引用修改该数据；指针本身是变量，可以指向其他的内存单元。
- 只有一个const，如果const位于\*右侧，表示指针本身是常量，不能指向其他内存地址；指针所指的数据可以通过解引用修改。
- 两个const，\*左右各一个，表示指针和指针所指数据都不能修改。

### const修饰函数参数

传递过来的参数在函数内不可以改变，与上面修饰变量时的性质一样，一般与引用&同时使用。

### const修饰成员函数

- const修饰的成员函数不能修改任何的成员变量(mutable修饰的变量除外)
- const成员函数不能调用非const成员函数，因为非const成员函数可以会修改成员变量

## inline与宏的区别

1. 内联函数在编译时展开，宏在预编译时展开；
1. 内联函数直接嵌入到目标代码中，宏是简单的做文本替换；
1. 内联函数有类型检测、语法判断等功能，而宏没有；
2. inline可以作为类的成员函数，可以使用所在类的保护成员及私有成员；
1. 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义；
2. 如果函数的代码较长，使用内联将消耗过多内存
3. 如果函数体内有循环，那么执行函数代码时间比调用开销大。

# 数据库学习笔记

-----

## 范式

### 第一范式

如果关系模式R的所有属性的值域中**每一个值都是不可再分**的值，则称R属于第一范式模式。

### 第二范式

如果关系模式R为第一范式，并且R中**每一个非主属性完全函数依赖于R的某个候选键**，则称R为第二范式模式。如果A是关系模式R的候选键的一个属性，则称A是R的主属性，否则称A是R的非主属性。

### 第三范式

如果关系模式R是第二范式，且**每个非主属性都不传递依赖于R的候选键**，则称R是第三范式的模式。

## 数据库事务

**定义：**数据库事务是指作为单个逻辑工作单元执行的一系列操作，是一个不可分割的工作单位。

- 事务的原子性：指一个事务要么全部执行，要么不执行。
- 事务的一致性：指事务的运行并不改变数据库中数据的一致性。例如，完整性约束了a + b = 10，一个事务改变了a，那么b也应该随之改变。
- 事务的独立性：指两个以上的事务不会出现交错执行的状态。

## 索引

- 单列索引
	- 普通索引：基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值
	- 唯一索引：索引列中的值必须是唯一的，但是允许为空值
	- 主键索引：特殊的唯一索引，不允许有空置
- 组合索引
- 全文索引
- 空间索引

# 设计模式

-----
