# C++学习笔记

-----

## 继承构造函数

### 为什么要引入继承构造函数？

如果基类的构造函数很多，那么子类的构造函数想要实现同样多的构造接口，必须一一调用基类的构造函数，有点麻烦，所以C++11引入继承构造函数

```
class _A
    {
public:
    _A( int _InInt ) {;}
    _A( double _InDouble, int _InInt ) {;}
    _A( float _InFloat, int _InInt, const char* _Char ) {;}
    };
 
   
class _B : public _A
    {
public:
   using _A::_A;            // 使用_A中的构造函数
    // Somthing...
    virtual void _ExtraInterface() {;}
    };
```

（1） C++11中的继承构造函数特性最有用的场合就是，派生类只是在基类的基础上添加了几个新的接口, 这个时候继承构造函数最能够展现威力.但是缺陷就是, 继承构造函数只会初始化基类中的成员变量(毕竟只是从基类继承下来的), 对于派生类中的变量无能为力,

（2）不过，可以配合另一个C++11中的新特性: 数据成员就地初始化，来解决这个问题。但是，这种做法导致子类的成员不能在构造函数的参数列表中体现出来。

（3）一旦，子类继承了基类的构造函数，那么子类就不会自动生成默认构造函数。

#### 构造函数与析构函数的调用顺序

- 对于构造函数：基类构造函数 > 子类成员变量构造函数 > 子类构造函数
- 对于析构函数：子类析构函数 > 子类成员变量析构函数 > 基类析构函数

可以看出构造函数的调用过程和析构函数的调用过程正好相反。

## 什么是可调用对象？

C++中有几种可调用对象：函数，函数指针，lambda表达式，bind创建的对象，以及重载了函数调用符的类。

## 四叉树算法

如何判断一个点是否落入多个矩形空间内？

## 设计模式

## 多线程

多线程锁类型？

并发无锁队列如何实现？

## 继承

多态是如何实现的？

通过父类调用接口，如何确定调用的是父类还是子类的接口？

## 图

如何判断一个有向图是否有环？

## 智能指针

## 内联函数与宏定义的区别

1. 内联函数在运行时可调试，而宏定义不可以;
2. 编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），而宏定义则不会； 
3. 内联函数可以访问类的成员变量，宏定义则不能； 
4. 在类中声明同时定义的成员函数，自动转化为内联函数。

在调用一个内联函数时，编译器首先检查调用是否正确（进行类型安全检查，或者进行自动类型转换，当然对所有的函数都一样）。如果正确，内联函数的代码就会直接替换函数调用，于是省去了函数调用的开销。这个过程与预处理有显著的不同，因为预处理器不能进行类型安全检查，或者进行自动类型转换。

## memmove与memcpy的区别及实现

#### 1.与字符串函数strcpy区别：

- memcpy与memmove都是对内存进行拷贝可以拷贝任何内容，而strcpy仅是对字符串进行操作。
- memcpy与memmove拷贝多少是通过其第三个参数进行控制而strcpy是当拷贝至'\0'停止。

#### 2.函数说明：         

- memcpy函数的功能是从源src所指的内存地址的起始位置开始拷贝N个字节到目标dst所指的内存地址的起始位置中。
- memmove函数的功能同memcpy基本一致，但是当src区域和dst内存区域重叠时，memcpy可能会出现错误，而memmove能正确进行拷贝。

## 覆盖、重载和多态的区别

#### 覆盖：

在基类中定义了一个非虚拟函数，然后在派生类中又定义了一个同名同参数同返回类型的函数，这就是覆盖了。在派生类对象上直接调用这个函数名，只会调用派生类中的那个。

#### 重载：

在基类中定义了一个非虚拟函数，然后在派生类中定义一个同名，但是具有不同的参数表的函数，这就是重载。在派生类对象上调用这几个函数时，用不同的参数会调用到不同的函数，有可能会直接调用到基类中的那个。

#### 多态：

在基类中定义了一个虚拟函数，然后在派生类中又定义一个同名，同参数表的函数，这就是多态。多态是这3种情况中唯一采用动态绑定技术的一种情况。也就是说，通过一个基类指针来操作对象，如果对象是基类对象，就会调用基类中的那个函数，如果对象实际是派生类对象，就会调用派声类中的那个函数，调用哪个函数并不由函数的参数表决定，而是由函数的实际类型决定。

## "."操作与"->"操作的区别

"."操作用于对象访问其成员，而"->"则是指针访问对象成员。

#### 迭代器

迭代器是一种将`operator*, operator-->, operator++, operator--`等指针相关操作予以重载的模板类。

## 面向对象的五个基本原则： 

- 单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。 
- 开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。 
- Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。 
- 依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 
- 接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口

## 栈、堆、全局等的区别

1. 栈区（stack）— 由编译器自动分配释放 ，存放为运行函数而分配的局部变量、函数参数、返回数据、返回地址等。
2. 堆区（heap） — 一般由程序员分配释放， new, malloc之类的，若程序员不释放，程序结束时可能由OS回收 。
3. 全局区（静态区）（static）— 存放全局变量、静态数据、常量。程序结束后由系统释放。
4. 文字常量区 — 常量字符串就是放在这里的。程序结束后由系统释放。
5. 程序代码区 — 存放函数体（类成员函数和全局函数）的二进制代码。

## unordered_map的key值限定

只能使用基本类型以及string和智能指针作为unordered_map的key值，如果需要使用别的自定义类型作为key值需要实现对应的hash函数。

## 静态数组与动态数组的区别

静态数组[]分配在栈上，由系统自动管理；动态数组通过new申请分配在堆上，需要用完后自己用delete释放空间。

## new/delete malloc/free区别和联系

- 一个new对应一个delete，一个new[]对应一个delete[]，一个malloc对应一个free
- malloc开辟空间类型大小需手动计算，new是由编译器自己计算
- malloc返回类型为void*,必须强制类型转换对应类型指针，new则直接返回对应类型指针
- malloc开辟内存时返回内存地址要检查判空，因为若它可能开辟失败会返回NULL；new则不用判断，因为内存分配失败时，它会抛出异常bac_alloc,可以使用异常机制
- 无论释放几个空间大小，free只传递指针，多个对象时delete需加[]（原因在第3）
- malloc/free为函数只是开辟空间并释放，new/delete则不仅会开辟空间，并调用构造函数和析构函数进行初始化和清理
- new/delete底层是基于malloc/free来实现的，而malloc/free不能基于new/delete实现
- 因为new/delete是操作符，它调用operator new / operator delete,它们可以被重载，在标准库里它有8个重载版本；而malloc/free不可以重载

## 大小端模式

- 大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。
- 小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。