# C++学习笔记

-----

## 继承构造函数

### 为什么要引入继承构造函数？

如果基类的构造函数很多，那么子类的构造函数想要实现同样多的构造接口，必须一一调用基类的构造函数，有点麻烦，所以C++11引入继承构造函数

```
class _A
    {
public:
    _A( int _InInt ) {;}
    _A( double _InDouble, int _InInt ) {;}
    _A( float _InFloat, int _InInt, const char* _Char ) {;}
    };
 
   
class _B : public _A
    {
public:
   using _A::_A;            // 使用_A中的构造函数
    // Somthing...
    virtual void _ExtraInterface() {;}
    };
```

（1） C++11中的继承构造函数特性最有用的场合就是，派生类只是在基类的基础上添加了几个新的接口, 这个时候继承构造函数最能够展现威力.但是缺陷就是, 继承构造函数只会初始化基类中的成员变量(毕竟只是从基类继承下来的), 对于派生类中的变量无能为力,

（2）不过，可以配合另一个C++11中的新特性: 数据成员就地初始化，来解决这个问题。但是，这种做法导致子类的成员不能在构造函数的参数列表中体现出来。

（3）一旦，子类继承了基类的构造函数，那么子类就不会自动生成默认构造函数。

### 构造函数与析构函数的调用顺序

- 对于构造函数：基类构造函数 > 子类成员变量构造函数 > 子类构造函数
- 对于析构函数：子类析构函数 > 子类成员变量析构函数 > 基类析构函数

可以看出构造函数的调用过程和析构函数的调用过程正好相反。

## 什么是可调用对象？

C++中有几种可调用对象：函数，函数指针，lambda表达式，bind创建的对象，以及重载了函数调用符的类。

## 四叉树算法

如何判断一个点是否落入多个矩形空间内？

## 设计模式

## 多线程

多线程锁类型？

并发无锁队列如何实现？

## 继承

多态是如何实现的？

通过父类调用接口，如何确定调用的是父类还是子类的接口？

## 图

如何判断一个有向图是否有环？

## 智能指针

auto_ptr \<T\>

普通指针在delete的时候只会释放指针所指向的内存空间，但是指针依旧存在并指向该内存空间，如果不把指针置为null该指针将变为野指针。 智能指针在delete之后会自动删除此指针，避免了野指针的出现。

auto_ptr在进行复制动作的时候会使它（被复制物）指向null

## 内联函数与宏定义的区别

1. 内联函数在运行时可调试，而宏定义不可以;
2. 编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），而宏定义则不会； 
3. 内联函数可以访问类的成员变量，宏定义则不能； 
4. 在类中声明同时定义的成员函数，自动转化为内联函数。

在调用一个内联函数时，编译器首先检查调用是否正确（进行类型安全检查，或者进行自动类型转换，当然对所有的函数都一样）。如果正确，内联函数的代码就会直接替换函数调用，于是省去了函数调用的开销。这个过程与预处理有显著的不同，因为预处理器不能进行类型安全检查，或者进行自动类型转换。

## memmove与memcpy的区别及实现

### 1.与字符串函数strcpy区别：

- memcpy与memmove都是对内存进行拷贝可以拷贝任何内容，而strcpy仅是对字符串进行操作。
- memcpy与memmove拷贝多少是通过其第三个参数进行控制而strcpy是当拷贝至'\0'停止。

### 2.函数说明：         

- memcpy函数的功能是从源src所指的内存地址的起始位置开始拷贝N个字节到目标dst所指的内存地址的起始位置中。
- memmove函数的功能同memcpy基本一致，但是当src区域和dst内存区域重叠时，memcpy可能会出现错误，而memmove能正确进行拷贝。

## 覆盖、重载和多态的区别及联系

### 覆盖：

在基类中定义了一个非虚拟函数，然后在派生类中又定义了一个同名同参数同返回类型的函数，这就是覆盖了。在派生类对象上直接调用这个函数名，只会调用派生类中的那个。

### 重载：

在基类中定义了一个非虚拟函数，然后在派生类中定义一个同名，但是具有不同的参数表的函数，这就是重载。在派生类对象上调用这几个函数时，用不同的参数会调用到不同的函数，有可能会直接调用到基类中的那个。

### 多态：

在基类中定义了一个虚拟函数，然后在派生类中又定义一个同名，同参数表的函数，这就是多态。多态是这3种情况中唯一采用动态绑定技术的一种情况。也就是说，通过一个基类指针来操作对象，如果对象是基类对象，就会调用基类中的那个函数，如果对象实际是派生类对象，就会调用派声类中的那个函数，调用哪个函数并不由函数的参数表决定，而是由函数的实际类型决定。

## "."操作与"->"操作的区别

"."操作用于对象访问其成员，而"->"则是指针访问对象成员。

### 迭代器

迭代器是一种将`operator*, operator-->, operator++, operator--`等指针相关操作予以重载的模板类。

## 面向对象的五个基本原则： 

- 单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。 
- 开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。 
- Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。 
- 依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 
- 接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口

## 内存管理

1. 栈区（stack）— 由编译器自动分配释放 ，存放为运行函数而分配的局部变量、函数参数、返回数据、返回地址等。
2. 堆区（heap） — 一般由程序员分配释放， new, malloc之类的，若程序员不释放，程序结束时可能由OS回收 。
3. 全局区（静态区）（static）— 存放全局变量、静态数据、常量。程序结束后由系统释放。
4. 文字常量区 — 常量字符串就是放在这里的。程序结束后由系统释放。
5. 程序代码区 — 存放函数体（类成员函数和全局函数）的二进制代码。

### 堆和栈的区别

1. **管理方式不同：**对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。
2. **空间大小不同：**一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的。
3. **碎片问题：**对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。
4. **生长方向不同：**对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。
5. **分配方式不同：**堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。
6. **分配效率不同：**栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。

### calloc和malloc和alloca的区别

calloc跟malloc的区别：calloc在动态分配完内存后，自动初始化该内存空间为零，而malloc不初始化，里边数据是随机的垃圾数据。_alloca是在栈(stack)上申请空间，用完马上就释放。


## unordered_map的key值限定

只能使用基本类型以及string和智能指针作为unordered_map的key值，如果需要使用别的自定义类型作为key值需要实现对应的hash函数。

## 静态数组与动态数组的区别

静态数组[]分配在栈上，由系统自动管理；动态数组通过new申请分配在堆上，需要用完后自己用delete释放空间。

## new/delete malloc/free区别和联系

- 一个new对应一个delete，一个new[]对应一个delete[]，一个malloc对应一个free
- malloc开辟空间类型大小需手动计算，new是由编译器自己计算
- malloc返回类型为void*,必须强制类型转换对应类型指针，new则直接返回对应类型指针
- malloc开辟内存时返回内存地址要检查判空，因为若它可能开辟失败会返回NULL；new则不用判断，因为内存分配失败时，它会抛出异常bac_alloc,可以使用异常机制
- 无论释放几个空间大小，free只传递指针，多个对象时delete需加[]（原因在第3）
- malloc/free为函数只是开辟空间并释放，new/delete则不仅会开辟空间，并调用构造函数和析构函数进行初始化和清理
- new/delete底层是基于malloc/free来实现的，而malloc/free不能基于new/delete实现
- 因为new/delete是操作符，它调用operator new / operator delete,它们可以被重载，在标准库里它有8个重载版本；而malloc/free不可以重载

## 大小端模式

- 大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。
- 小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。

## 指针常量与常量指针

1. const int p; 
- const int* p; 
- int const* p; 
- int * const p;
- const int * const p;
- int const * const p;

从右往左读，遇到p就换成p is a，遇到*就换成point to.

const在\*左边说明指向的内容是常量，const在\*右边说明指针是常量

1. p is a int const
2. p is a point to int const
3. p is a point to const int
4. p is a const point to int
5. p is a const point to int const
6. p is a const point to const int

## struct与union

struct的长度一定是最长的数据元素的整数倍，union的大小就是最长的数据元素的大小，union内部各数据元素共享这一内存。

## static

### 静态成员函数

静态成员函数不能访问一般的数据成员，只能访问静态数据成员，也只能调用其他的静态成员函数。

通常，当前对象的地址(this)是被隐式地传递到被调用的函数的，但一个静态成员函数没有this，所以它无法访问一般的成员。

一个静态成员是与一个类相连，而不是与一个特定的对象相连。

## inline与宏的区别

1. 内联函数在编译时展开，宏在预编译时展开；
1. 内联函数直接嵌入到目标代码中，宏是简单的做文本替换；
1. 内联函数有类型检测、语法判断等功能，而宏没有；
2. inline可以作为类的成员函数，可以使用所在类的保护成员及私有成员；
1. 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义；
2. 如果函数的代码较长，使用内联将消耗过多内存
3. 如果函数体内有循环，那么执行函数代码时间比调用开销大。

# 数据库学习笔记

-----

## 范式

### 第一范式

如果关系模式R的所有属性的值域中**每一个值都是不可再分**的值，则称R属于第一范式模式。

### 第二范式

如果关系模式R为第一范式，并且R中**每一个非主属性完全函数依赖于R的某个候选键**，则称R为第二范式模式。如果A是关系模式R的候选键的一个属性，则称A是R的主属性，否则称A是R的非主属性。

### 第三范式

如果关系模式R是第二范式，且**每个非主属性都不传递依赖于R的候选键**，则称R是第三范式的模式。

## 数据库事务

**定义：**数据库事务是指作为单个逻辑工作单元执行的一系列操作，是一个不可分割的工作单位。

- 事务的原子性：指一个事务要么全部执行，要么不执行。
- 事务的一致性：指事务的运行并不改变数据库中数据的一致性。例如，完整性约束了a + b = 10，一个事务改变了a，那么b也应该随之改变。
- 事务的独立性：指两个以上的事务不会出现交错执行的状态。