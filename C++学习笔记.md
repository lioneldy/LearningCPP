# C++学习笔记

-----

## 继承构造函数

### 为什么要引入继承构造函数？

如果基类的构造函数很多，那么子类的构造函数想要实现同样多的构造接口，必须一一调用基类的构造函数，有点麻烦，所以C++11引入继承构造函数

```
class _A
    {
public:
    _A( int _InInt ) {;}
    _A( double _InDouble, int _InInt ) {;}
    _A( float _InFloat, int _InInt, const char* _Char ) {;}
    };
 
   
class _B : public _A
    {
public:
   using _A::_A;            // 使用_A中的构造函数
    // Somthing...
    virtual void _ExtraInterface() {;}
    };
```

（1） C++11中的继承构造函数特性最有用的场合就是，派生类只是在基类的基础上添加了几个新的接口, 这个时候继承构造函数最能够展现威力.
但是缺陷就是, 继承构造函数只会初始化基类中的成员变量(毕竟只是从基类继承下来的), 对于派生类中的变量无能为力,

（2）不过，可以配合另一个C++11中的新特性: 数据成员就地初始化，来解决这个问题。但是，这种做法导致子类的成员不能在构造函数的参数列表中体现出来。

（3）一旦，子类继承了基类的构造函数，那么子类就不会自动生成默认构造函数。

## 什么是可调用对象？

C++中有几种可调用对象：函数，函数指针，lambda表达式，bind创建的对象，以及重载了函数调用符的类。

## 四叉树算法

如何判断一个点是否落入多个矩形空间内？

## 设计模式

## 多线程

多线程锁类型？

并发无锁队列如何实现？

## 继承

多态是如何实现的？

通过父类调用接口，如何确定调用的是父类还是子类的接口？

## 图

如何判断一个有向图是否有环？

## 智能指针

## 内联函数与宏定义的区别

1. 内联函数在运行时可调试，而宏定义不可以;
2. 编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），而宏定义则不会； 
3. 内联函数可以访问类的成员变量，宏定义则不能； 
4. 在类中声明同时定义的成员函数，自动转化为内联函数。

在调用一个内联函数时，编译器首先检查调用是否正确（进行类型安全检查，或者进行自动类型转换，当然对所有的函数都一样）。如果正确，内联函数的代码就会直接替换函数调用，于是省去了函数调用的开销。这个过程与预处理有显著的不同，因为预处理器不能进行类型安全检查，或者进行自动类型转换。

## memmove与memcpy的区别及实现

#### 1.与字符串函数strcpy区别：

- memcpy与memmove都是对内存进行拷贝可以拷贝任何内容，而strcpy仅是对字符串进行操作。
- memcpy与memmove拷贝多少是通过其第三个参数进行控制而strcpy是当拷贝至'\0'停止。

#### 2.函数说明：         

- memcpy函数的功能是从源src所指的内存地址的起始位置开始拷贝N个字节到目标dst所指的内存地址的起始位置中。
- memmove函数的功能同memcpy基本一致，但是当src区域和dst内存区域重叠时，memcpy可能会出现错误，而memmove能正确进行拷贝。

## 覆盖、重载和多态的区别

#### 覆盖：

在基类中定义了一个非虚拟函数，然后在派生类中又定义了一个同名同参数同返回类型的函数，这就是覆盖了。在派生类对象上直接调用这个函数名，只会调用派生类中的那个。

#### 重载：

在基类中定义了一个非虚拟函数，然后在派生类中定义一个同名，但是具有不同的参数表的函数，这就是重载。在派生类对象上调用这几个函数时，用不同的参数会调用到不同的函数，有可能会直接调用到基类中的那个。

#### 多态：

在基类中定义了一个虚拟函数，然后在派生类中又定义一个同名，同参数表的函数，这就是多态。多态是这3种情况中唯一采用动态绑定技术的一种情况。也就是说，通过一个基类指针来操作对象，如果对象是基类对象，就会调用基类中的那个函数，如果对象实际是派生类对象，就会调用派声类中的那个函数，调用哪个函数并不由函数的参数表决定，而是由函数的实际类型决定。

## "."操作与"->"操作的区别

"."操作用于对象访问其成员，而"->"则是指针访问对象成员。